package treasury.crypto.keygen

import java.math.BigInteger

import treasury.crypto.core._
import treasury.crypto.keygen.datastructures.C1Share
import treasury.crypto.nizk.ElgamalDecrNIZK
import treasury.crypto.voting.Tally
import treasury.crypto.voting.ballots.{Ballot, ExpertBallot, VoterBallot}

import scala.util.Try

/*
* DecryptionManager encapsulates logic related to generation/recover of the tally decryption shares
* It can also be used to generate decryption shares (namely decrypted C1 components) of the faulty committee member who
* refused to publish shares by himself, so his secret key was publicly reconstructed.
*/
class DecryptionManager(cs:               Cryptosystem,
                        ballots:          Seq[Ballot],
                        recoveryThreshold: Integer = 0) {

  lazy val votersBallots = ballots.collect { case b: VoterBallot => b }
  assert(votersBallots.forall(_.uvDelegations.length == votersBallots.head.uvDelegations.length))

  lazy val expertsBallots = ballots.collect { case b: ExpertBallot => b }
  assert(votersBallots.forall(_.uvChoice.length == votersBallots.head.uvChoice.length))

  lazy val delegationsSum: Seq[Ciphertext] = Tally.computeDelegationsSum(cs, votersBallots)

  /**
    * Validates decrypted share generated by some committee member. Each decryption share (C1Share) should contain
    * an array of the decrypted c1 components for the corresponding ciphertexts.
    *
    * @param issuerPubKey A public key of a committee member who created the C1Share
    * @param c1Share C1Share datastructure containing an array of decrypted c1 components for the array of ciphertexts
    *                together with NIZK proofs that these decrypted components are valid
    * @param vectorForValidation An array of ciphertexts that should be decrypted with c1 components from C1Share
    * @return Success(_) if succeeds
    */
  private def validateC1Share(issuerPubKey: PubKey, c1Share: C1Share, vectorForValidation: Seq[Ciphertext]): Try[Unit] = Try {
    require(c1Share.decryptedC1.length == vectorForValidation.length, "Wrong C1Share lenght")

    for (i <- vectorForValidation.indices) {
      val ciphertext = vectorForValidation(i)
      val C1sk = c1Share.decryptedC1(i)._1
      val plaintext = ciphertext._2.subtract(C1sk)
      val proof = c1Share.decryptedC1(i)._2

      require(ElgamalDecrNIZK.verifyNIZK(cs, issuerPubKey, ciphertext, plaintext, proof), "Invalid proof")
    }
  }

  /**
    * Whapper over validateC1Share(issuerPubKey: PubKey, c1Share: C1Share, vectorForValidation: Seq[Ciphertext])
    * Validates C1Share issued specifically for the first stage of the tally phase when committee members jointly
    * decrypts delegations part of the summed unit vector
    *
    * @param issuerPubKey A public key of a committee member who created the C1Share
    * @param c1Share C1Share containint an array of decrypted c1 components for the summed ciphertexts that
    *                represent delegation bits of the unit vector.
    * @return Success(_) if succeeds
    */
  def validateDelegationsC1(issuerPubKey: PubKey, c1Share: C1Share): Try[Unit] = {
    validateC1Share(issuerPubKey, c1Share, delegationsSum)
  }

  /**
    * Whapper over validateC1Share(issuerPubKey: PubKey, c1Share: C1Share, vectorForValidation: Seq[Ciphertext])
    * Validates C1Share issued specifically for the second stage of the tally phase when committee members jointly
    * decrypts results (choices part of the summed unit vector)
    *
    * @param issuerPubKey A public key of a committee member who created the C1Share
    * @param choicesC1 C1Share containint an array of decrypted c1 components for the summed ciphertexts that
    *                  represent choices bits of the unit vector.
    * @param delegations An array that represents number of delegations for each expert
    * @return Success(_) if succeeds
    */
  def validateChoicesC1(issuerPubKey: PubKey,
                        choicesC1: C1Share,
                        delegations: Seq[Element]): Try[Unit] = {
    val choicesSum = Tally.computeChoicesSum(cs, votersBallots, expertsBallots, delegations)
    validateC1Share(issuerPubKey, choicesC1, choicesSum)
  }

  /**
    * Generate C1Share for the delegations part of the summed unit vector. This function should be used by
    * a committee member on the first stage of the Tally.
    * Note that for each proposal there would be a different set of ballots, thus C1Share would be created for each
    * proposal separately
    *
    * @param issuerId Committee member identifier
    * @param proposalId Proposal identifier
    * @param secretKey Secret key of the committee member
    * @return C1Share
    */
  def decryptC1ForDelegations(issuerId: Integer, proposalId: Int, secretKey: PrivKey): C1Share = {
    val shares = delegationsSum.map { unit =>
      val decryptedC1 = unit._1.multiply(secretKey).normalize
      val proof = ElgamalDecrNIZK.produceNIZK(cs, unit, secretKey)
      (decryptedC1, proof)
    }

    C1Share(proposalId, issuerId, shares)
  }

  /**
    * Generate C1Share for the choices part of the summed unit vector. This function should be used by
    * a committee member on the second stage of the Tally.
    * Note that for each proposal there would be a different set of ballots, thus C1Share would be created for each
    * proposal separately
    *
    * @param issuerId Committee member identifier
    * @param proposalId Proposal identifier
    * @param secretKey Secret key of the committee member
    * @param delegations An array that represents number of delegations for each expert
    * @return C1Share
    */
  def decryptC1ForChoices(issuerId: Integer, proposalId: Int, secretKey: PrivKey, delegations: Seq[Element]): C1Share = {
    val choicesSum = Tally.computeChoicesSum(cs, votersBallots, expertsBallots, delegations)

    val shares = choicesSum.map { unit =>
      val decryptedC1 = unit._1.multiply(secretKey).normalize
      val proof = ElgamalDecrNIZK.produceNIZK(cs, unit, secretKey)
      (decryptedC1, proof)
    }

    C1Share(proposalId, issuerId, shares)
  }

  /**
    * Decrypt a vector of c1 components by multiplying them on the secret key
    *
    * @param privKeys a list of priv keys, the `vector` will be decrypted for each key separately
    * @param vector vector of Points to decrypt
    * @return a list of decrypted vectors (for each secret key),
    *         each vector itself is a seq of Points, thus there will be Seq[ Seq[Point] ]
    */
  def decryptVector(privKeys: Seq[PrivKey], vector: Seq[Point]): Seq[Seq[Point]] = {
    privKeys.map(key => vector.map(_.multiply(key)))
  }

  /**
    * Recover decrypted C1 of the faulty committee members (who didn't submit C1Share by themselves).
    * Provided with KeyShares from operating committee members we are able to reconstruct secret keys of the faulty members
    * and then compute decrypted C1 for delegations
    *
    * @param skShares list of KeyShares, each of them is produced by a working committee member and represents his shares
    *                 for all faulty members
    * @return a list of decrypted C1s for delegations, for each reconstructed private key
    */
  def recoverDelegationsC1(skShares: Seq[KeyShares]): Seq[Seq[Point]] = {
    val decryptionViolatorsSKs = reconstructSecretKeys(skShares)
    decryptVector(decryptionViolatorsSKs, delegationsSum.map(_._1))
  }

  /**
    * Recover decrypted C1 of the faulty committee members (who didn't submit C1Share by themselves).
    * Provided with KeyShares from operating committee members we are able to reconstruct secret keys of the faulty members
    * and then compute decrypted C1 for choices
    *
    * @param skShares list of KeyShares, each of them is produced by a working committee member and represents his shares
    *                 for all faulty members
    * @param choicesSum previously computed sum of the ciphertexts that represent choices bits of the unit vector
    * @return a list of decrypted C1s for choices, for each reconstructed private key
    */
  def recoverChoicesC1(skShares: Seq[KeyShares], choicesSum: Seq[Ciphertext]): Seq[Seq[Point]] = {
    val decryptionViolatorsSKs = reconstructSecretKeys(skShares)
    decryptVector(decryptionViolatorsSKs, choicesSum.map(_._1))
  }

  /**
    * Since each private key of a committee member (CM) is distributed through the VSS scheme to the other CMs
    * it is possible to reconstruct it in case of faulty behaviour.
    * This function helps to reconstruct private keys of the faulty CMs by key shares submitted by other committe members.
    *
    * @param skShares An array of KeyShares submitted by different committee members. Each KeyShares structure contains
    *                 shares of private keys for the all faulty committee members.
    * @return An array of reconstructed private keys
    *
    * TODO: what if different CMs submit KeyShares with different set of shares? (I mean for different set of faulty CMs)
    */
  def reconstructSecretKeys(skShares: Seq[KeyShares]): Array[BigInteger] = {
    val decryptionViolatorsShares = skShares.map(
      member =>
        member.keyShares.map(
          share =>
            (share.ownerID, OpenedShare(member.issuerID, HybridPlaintext(cs.infinityPoint, share.share.toByteArray)))
        )
    ).map(_.sortBy(_._1).map(_._2)).transpose

    decryptionViolatorsShares.map(LagrangeInterpolation.restoreSecret(cs, _, recoveryThreshold)).toArray
  }

  @deprecated("Better to use Tally.decryptVectorOnC1 directly")
  def computeDelegations(delegationsC1: Seq[Seq[Point]]): Seq[Element] = {
    Tally.decryptVectorOnC1(cs, delegationsC1, delegationsSum)
  }

  @deprecated("Better to use Tally.computeChoicesSum directly")
  def computeChoicesSum(delegations: Seq[Element]): Seq[Ciphertext] = {
    Tally.computeChoicesSum(cs, votersBallots, expertsBallots, delegations)
  }
}
